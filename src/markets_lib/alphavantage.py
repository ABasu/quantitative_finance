#!/usr/bin/env python# encoding=utf8"""A set of functions to make api calls to alphavantage. https://www.alphavantage.co/documentation/Ideally, the API key should be read from a an external config fileparse_response(call_api(symbol="SPY", function="TIME_SERIES_DAILY_ADJUSTED"), function='TIME_SERIES_DAILY_ADJUSTED')The above generates a [(timestamo, price), ...] series"""import csv, logging, re, requests, timelogging.basicConfig(format = '%(asctime)-25s %(message)s', level = logging.INFO)# load alphavantage api keyapikey = [l for l in open('apikey.cfg', 'r').readlines() if re.search('^apikey\s*=', l)][0].split('=')[1].strip().strip("'")##############################################################################def call_api(symbol, function='TIME_SERIES_WEEKLY_ADJUSTED', parameters={}, apikey=apikey):    """    Calls the Alphavantage API. Returns the JSON or CSV response as a dict or list.     Most calls return JSON but INTRADAY data is CSV. Response can be parsed into     a DataFrame using parse_response.        Parameters    ----------    symbol : string        A ticker for a stock.    function : string, optional        The API function to be called. Look up on alphavantage. The default is 'TIME_SERIES_WEEKLY_ADJUSTED'.    apikey : string, optional        The API key for alphavantage. The default is apikey.    Returns    -------    response : dict or list        The entire json or csv response object is returned.    """    # Requires multiple calls and returns CSV    if function=='TIME_SERIES_INTRADAY_EXTENDED':        pause_between_queries = parameters.pop('pause_between_queries')        response = []        for year in range(1,3):            for month in range(1,13):                parameters['slice'] = 'year{}month{}'.format(year, month)                url = generate_api_url(function=function, symbol=symbol, parameters=parameters, apikey=apikey)                print('{}: Downloading {}: year{}month{}'.format(symbol, function, year, month))                with requests.Session() as s:                    download = s.get(url)                    decoded_content = download.content.decode('utf-8')                    cr = csv.reader(decoded_content.splitlines(), delimiter=',')                    my_list = list(cr)                    response.extend(my_list[1:])                time.sleep(pause_between_queries)    # Returns JSON    else:        url = generate_api_url(function=function, symbol=symbol, parameters=parameters, apikey=apikey)        try:            response = requests.get(url).json()        except Exception as e:            logging.exception(e)            response = None    return response ##############################################################################def generate_api_url(symbol, function='TIME_SERIES_WEEKLY_ADJUSTED', parameters={}, apikey=apikey):    """    Parameters    ----------    symbol : string        A ticker for a stock.    function : string, optional        The API function to be called. Look up on alphavantage. The default is 'TIME_SERIES_WEEKLY_ADJUSTED'.    apikey : string, optional        The API key for alphavantage. The default is apikey.    Returns    -------    url : string        The formatted url for the API call.    """    parameters = ['{}={}'.format(p, v) for p, v in parameters.items()]    parameters = '&'+'&'.join(parameters)    url = 'https://www.alphavantage.co/query?function={}&symbol={}&apikey={}{}'.format(function, symbol, apikey, parameters)    return url    ##############################################################################def parse_response(response, function='TIME_SERIES_WEEKLY_ADJUSTED', symbol='', intraday_mins=15):    """    Depending on the function call, returns either a timeseries as a list of     tuples or a dictionary (for OVERVIEW).        Parameters    ----------    response : dict        A dictionary of the API response.    function : TYPE, optional        The API function to be called. Look up on alphavantage. The default is 'TIME_SERIES_WEEKLY_ADJUSTED'.    Returns    -------    List of tuples. Or dictionary        Returns (date, price) list of Tuples. Or dictionary with over view         key, value pairs.    """    try:        # This returns CSV        if function == 'TIME_SERIES_INTRADAY_EXTENDED':             cols = [c.title() for c in 'Date,open,high,low,close,volume'.split(',')]            parsed = response        else: # These return Dicts/JSON            if function == 'TIME_SERIES_WEEKLY_ADJUSTED':                main_key = 'Weekly Adjusted Time Series'                sub_keys = ['1. open', '2. high', '3. low', '4. close', '5. adjusted close', '6. volume', '7. dividend amount']            elif function == 'TIME_SERIES_DAILY':                main_key = 'Time Series (Daily)'                sub_keys = ['1. open', '2. high', '3. low', '4. close', '5. volume']            elif function == 'TIME_SERIES_INTRADAY':                main_key = 'Time Series ({}min)'.format(intraday_mins)                sub_keys = ['1. open', '2. high', '3. low', '4. close', '5. volume']            parsed = []            for timestamp in response[main_key]:                entry = [timestamp]                for sk in sub_keys:                    entry.append(response[main_key][timestamp][sk])                parsed.append(entry)            cols = ['Date'] + [sk.split()[-1].title() for sk in response[main_key][timestamp]]                                except:        logging.error('{}: {}'.format(symbol, response))        return None, None    return parsed, cols